{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Click MCP Server","text":"CI/CD Docs Package Meta <p>This provides an extensible MCP server that is compatible with any command line application that is based on Click.</p>"},{"location":"#navigation","title":"Navigation","text":"<p>Desktop readers can use keyboard shortcuts to navigate.</p> Keys Action <ul><li>, (comma)</li><li>p</li></ul> Navigate to the \"previous\" page <ul><li>. (period)</li><li>n</li></ul> Navigate to the \"next\" page <ul><li>/</li><li>s</li></ul> Display the search modal"},{"location":"api/","title":"API reference","text":""},{"location":"api/#click_mcp_server.server.ClickMCPServer","title":"ClickMCPServer","text":"<p>An MCP server that can be used to run Click commands, backed by Starlette and Uvicorn. Example usage:</p> <pre><code>from click_mcp_server import ClickMCPServer\n\nfrom mypkg.cli import cmd\n\nserver = ClickMCPServer(commands=[cmd], stateless=True)\nserver.run()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>Sequence[Command | ClickCommandQuery]</code> <p>The Click commands to expose as MCP tools.</p> required <p>Other Parameters:</p> Name Type Description <code>event_store</code> <code>EventStore | None</code> <p>Optional event store that allows clients to reconnect and receive missed events. If <code>None</code>, sessions are still tracked but not resumable.</p> <code>stateless</code> <code>bool</code> <p>Whether to create a completely fresh transport for each request with no session tracking or state persistence between requests.</p> <code>**app_settings</code> <code>Any</code> <p>Additional settings to pass to the Starlette application.</p> Source code in <code>src/click_mcp_server/server.py</code> <pre><code>class ClickMCPServer:\n    \"\"\"\n    An MCP server that can be used to run Click commands, backed by [Starlette](https://github.com/encode/starlette)\n    and [Uvicorn](https://github.com/encode/uvicorn). Example usage:\n\n    ```python\n    from click_mcp_server import ClickMCPServer\n\n    from mypkg.cli import cmd\n\n    server = ClickMCPServer(commands=[cmd], stateless=True)\n    server.run()\n    ```\n\n    Parameters:\n        commands: The Click commands to expose as MCP tools.\n\n    Other parameters:\n        event_store: Optional [event store](https://github.com/modelcontextprotocol/python-sdk/blob/v1.9.4/src/mcp/server/streamable_http.py#L79)\n            that allows clients to reconnect and receive missed events. If `None`, sessions are still tracked but not\n            resumable.\n        stateless: Whether to create a completely fresh transport for each request with no session tracking or state\n            persistence between requests.\n        **app_settings: Additional settings to pass to the Starlette [application][starlette.applications.Starlette].\n    \"\"\"\n\n    def __init__(\n        self,\n        commands: Sequence[click.Command | ClickCommandQuery],\n        *,\n        event_store: EventStore | None = None,\n        stateless: bool = False,\n        **app_settings: Any,\n    ) -&gt; None:\n        self.__command_queries = [c if isinstance(c, ClickCommandQuery) else ClickCommandQuery(c) for c in commands]\n        self.__app_settings = app_settings\n        self.__server: Server = Server(\"click_mcp_server\")\n        self.__session_manager = StreamableHTTPSessionManager(\n            app=self.__server,\n            event_store=event_store,\n            stateless=stateless,\n            json_response=True,\n        )\n\n        # Register handlers\n        self.__server.request_handlers[ListToolsRequest] = self.list_tools_handler\n        self.__server.request_handlers[CallToolRequest] = self.call_tool_handler\n\n    @property\n    def server(self) -&gt; Server:\n        \"\"\"\n        Returns:\n            The underlying [low-level server](https://github.com/modelcontextprotocol/python-sdk/blob/v1.9.4/src/mcp/server/lowlevel/server.py)\n                instance. You can use this to register additional handlers.\n        \"\"\"\n        return self.__server\n\n    @property\n    def session_manager(self) -&gt; StreamableHTTPSessionManager:\n        \"\"\"\n        Returns:\n            The underlying [session manager](https://github.com/modelcontextprotocol/python-sdk/blob/v1.9.4/src/mcp/server/streamable_http_manager.py#L29)\n                instance. You only need to use this if you want to override the `lifetime` context manager\n        \"\"\"\n        return self.__session_manager\n\n    @cached_property\n    def commands(self) -&gt; dict[str, ClickCommand]:\n        \"\"\"\n        Returns:\n            Dictionary used internally to store metadata about the exposed Click commands. Although it should not be\n                modified, the keys are the available MCP tool names and useful to know when overriding the default handlers.\n        \"\"\"\n        commands: dict[str, ClickCommand] = {}\n        for query in self.__command_queries:\n            for metadata in query:\n                tool_name = metadata.path.replace(\" \", \".\").replace(\"-\", \"_\")\n                tool = Tool(\n                    name=tool_name,\n                    description=metadata.schema[\"description\"],\n                    inputSchema=metadata.schema,\n                )\n                commands[tool_name] = ClickCommand(metadata, tool)\n\n        return commands\n\n    @cached_property\n    def routes(self) -&gt; list[Mount]:\n        \"\"\"\n        This would only be used directly if you want to add more routes in addition to the default `/mcp` route.\n\n        Returns:\n            The [routes](https://www.starlette.io/routing/#http-routing) to mount in the Starlette\n                [application][starlette.applications.Starlette].\n        \"\"\"\n        return [Mount(\"/mcp\", app=self.session_manager.handle_request)]\n\n    @asynccontextmanager\n    async def lifespan(self, app: Starlette) -&gt; AsyncIterator[None]:  # noqa: ARG002\n        \"\"\"\n        The default lifespan context manager used by the Starlette [application][starlette.applications.Starlette].\n        \"\"\"\n        async with self.session_manager.run():\n            yield\n\n    def list_command_tools(self) -&gt; list[Tool]:\n        \"\"\"\n        This would only be used directly if you want to override the handler for the `ListToolsRequest`.\n\n        Returns:\n            The MCP tools for the Click commands.\n        \"\"\"\n        return [command.tool for command in self.commands.values()]\n\n    async def list_tools_handler(self, _: ListToolsRequest) -&gt; ServerResult:\n        \"\"\"\n        The default handler for the `ListToolsRequest`.\n        \"\"\"\n        return ServerResult(ListToolsResult(tools=self.list_command_tools()))\n\n    async def call_tool_handler(self, req: CallToolRequest) -&gt; ServerResult:\n        \"\"\"\n        The default handler for the `CallToolRequest`.\n        \"\"\"\n        command = self.commands[req.params.name].metadata.construct(req.params.arguments)\n        try:\n            process = subprocess.run(command, encoding=\"utf-8\", capture_output=True)  # noqa: PLW1510\n        # This can happen if the command is not found\n        except subprocess.CalledProcessError as e:\n            return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=str(e))], isError=True))\n\n        if process.returncode:\n            msg = f\"{process.stdout}\\nThis command exited with non-zero exit code `{process.returncode}`: {command}\"\n            return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=msg)], isError=True))\n\n        return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=process.stdout)]))\n\n    def run(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Other parameters:\n            **kwargs: Additional settings to pass to the [`uvicorn.run`](https://www.uvicorn.org/#uvicornrun) function.\n        \"\"\"\n        app_settings = self.__app_settings.copy()\n        app_settings[\"routes\"] = self.routes\n        app_settings.setdefault(\"lifespan\", self.lifespan)\n        app = Starlette(**app_settings)\n        uvicorn.run(app, **kwargs)\n</code></pre>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.server","title":"server","text":"<pre><code>server: Server\n</code></pre> <p>Returns:</p> Type Description <code>Server</code> <p>The underlying low-level server instance. You can use this to register additional handlers.</p>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.session_manager","title":"session_manager","text":"<pre><code>session_manager: StreamableHTTPSessionManager\n</code></pre> <p>Returns:</p> Type Description <code>StreamableHTTPSessionManager</code> <p>The underlying session manager instance. You only need to use this if you want to override the <code>lifetime</code> context manager</p>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.commands","title":"commands","text":"<pre><code>commands: dict[str, ClickCommand]\n</code></pre> <p>Returns:</p> Type Description <code>dict[str, ClickCommand]</code> <p>Dictionary used internally to store metadata about the exposed Click commands. Although it should not be modified, the keys are the available MCP tool names and useful to know when overriding the default handlers.</p>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.routes","title":"routes","text":"<pre><code>routes: list[Mount]\n</code></pre> <p>This would only be used directly if you want to add more routes in addition to the default <code>/mcp</code> route.</p> <p>Returns:</p> Type Description <code>list[Mount]</code> <p>The routes to mount in the Starlette application.</p>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.lifespan","title":"lifespan","text":"<pre><code>lifespan(app: Starlette) -&gt; AsyncIterator[None]\n</code></pre> <p>The default lifespan context manager used by the Starlette application.</p> Source code in <code>src/click_mcp_server/server.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self, app: Starlette) -&gt; AsyncIterator[None]:  # noqa: ARG002\n    \"\"\"\n    The default lifespan context manager used by the Starlette [application][starlette.applications.Starlette].\n    \"\"\"\n    async with self.session_manager.run():\n        yield\n</code></pre>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.list_command_tools","title":"list_command_tools","text":"<pre><code>list_command_tools() -&gt; list[Tool]\n</code></pre> <p>This would only be used directly if you want to override the handler for the <code>ListToolsRequest</code>.</p> <p>Returns:</p> Type Description <code>list[Tool]</code> <p>The MCP tools for the Click commands.</p> Source code in <code>src/click_mcp_server/server.py</code> <pre><code>def list_command_tools(self) -&gt; list[Tool]:\n    \"\"\"\n    This would only be used directly if you want to override the handler for the `ListToolsRequest`.\n\n    Returns:\n        The MCP tools for the Click commands.\n    \"\"\"\n    return [command.tool for command in self.commands.values()]\n</code></pre>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.list_tools_handler","title":"list_tools_handler","text":"<pre><code>list_tools_handler(_: ListToolsRequest) -&gt; ServerResult\n</code></pre> <p>The default handler for the <code>ListToolsRequest</code>.</p> Source code in <code>src/click_mcp_server/server.py</code> <pre><code>async def list_tools_handler(self, _: ListToolsRequest) -&gt; ServerResult:\n    \"\"\"\n    The default handler for the `ListToolsRequest`.\n    \"\"\"\n    return ServerResult(ListToolsResult(tools=self.list_command_tools()))\n</code></pre>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.call_tool_handler","title":"call_tool_handler","text":"<pre><code>call_tool_handler(req: CallToolRequest) -&gt; ServerResult\n</code></pre> <p>The default handler for the <code>CallToolRequest</code>.</p> Source code in <code>src/click_mcp_server/server.py</code> <pre><code>async def call_tool_handler(self, req: CallToolRequest) -&gt; ServerResult:\n    \"\"\"\n    The default handler for the `CallToolRequest`.\n    \"\"\"\n    command = self.commands[req.params.name].metadata.construct(req.params.arguments)\n    try:\n        process = subprocess.run(command, encoding=\"utf-8\", capture_output=True)  # noqa: PLW1510\n    # This can happen if the command is not found\n    except subprocess.CalledProcessError as e:\n        return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=str(e))], isError=True))\n\n    if process.returncode:\n        msg = f\"{process.stdout}\\nThis command exited with non-zero exit code `{process.returncode}`: {command}\"\n        return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=msg)], isError=True))\n\n    return ServerResult(CallToolResult(content=[TextContent(type=\"text\", text=process.stdout)]))\n</code></pre>"},{"location":"api/#click_mcp_server.server.ClickMCPServer.run","title":"run","text":"<pre><code>run(**kwargs: Any) -&gt; None\n</code></pre> <p>Other Parameters:</p> Name Type Description <code>**kwargs</code> <code>Any</code> <p>Additional settings to pass to the <code>uvicorn.run</code> function.</p> Source code in <code>src/click_mcp_server/server.py</code> <pre><code>def run(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Other parameters:\n        **kwargs: Additional settings to pass to the [`uvicorn.run`](https://www.uvicorn.org/#uvicornrun) function.\n    \"\"\"\n    app_settings = self.__app_settings.copy()\n    app_settings[\"routes\"] = self.routes\n    app_settings.setdefault(\"lifespan\", self.lifespan)\n    app = Starlette(**app_settings)\n    uvicorn.run(app, **kwargs)\n</code></pre>"},{"location":"api/#click_mcp_server.server.ClickCommandQuery","title":"ClickCommandQuery","text":"<p>A wrapper around a root Click command that influences the collection behavior. Example usage:</p> <pre><code>from click_mcp_server import ClickCommandQuery, ClickMCPServer\n\nfrom mypkg.cli import cmd\n\n# Only expose the `foo` subcommand\nquery = ClickCommandQuery(cmd, include=r\"^foo$\")\nserver = ClickMCPServer(commands=[query])\nserver.run()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Command</code> <p>The Click command to query.</p> required <code>name</code> <code>str | None</code> <p>The expected name of the root command.</p> <code>None</code> <code>include</code> <code>str | Pattern | None</code> <p>A regular expression to include in the query.</p> <code>None</code> <code>exclude</code> <code>str | Pattern | None</code> <p>A regular expression to exclude in the query.</p> <code>None</code> <code>strict_types</code> <code>bool</code> <p>Whether to error on unknown types.</p> <code>False</code>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":"<p>Added:</p> <ul> <li>Add support for customizing the root command name</li> <li>Add support for more option types</li> <li>Add support for strict type checking</li> </ul> <p>Fixed:</p> <ul> <li>Fix options with dynamic default values</li> <li>The CLI now errors for specs that don't refer to a Click command object</li> </ul>"},{"location":"changelog/#001-2025-06-24","title":"0.0.1 - 2025-06-24","text":"<p>This is the initial public release.</p>"},{"location":"cli/","title":"CLI reference","text":""},{"location":"cli/#click-mcp-server","title":"click-mcp-server","text":"<p>Run an MCP server using a list of import paths to Click commands:</p> <pre><code>click-mcp-server pkg1.cli:foo pkg2.cli:bar\n</code></pre> <p>Filtering is supported. For example, if you have a CLI named <code>foo</code> and you only want to expose the subcommands <code>bar</code> and <code>baz</code>, excluding the <code>baz</code> subcommands <code>sub2</code> and <code>sub3</code>, you can do:</p> <pre><code>click-mcp-server pkg.cli:foo -i \"bar|baz\" -e \"baz (sub2|sub3)\"\n</code></pre> <p>Usage:</p> <pre><code>click-mcp-server [OPTIONS] [SPECS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--name</code>, <code>-n</code> text The expected name of the exposed command, multiple specs make the format: spec=name None <code>--include</code>, <code>-i</code> text The regular expression filter to include subcommands, multiple specs make the format: spec=regex None <code>--exclude</code>, <code>-e</code> text The regular expression filter to exclude subcommands, multiple specs make the format: spec=regex None <code>--strict-types</code> boolean Error on unknown types <code>False</code> <code>--debug</code> boolean Enable debug mode <code>False</code> <code>--host</code> text The host used to run the server (default: 127.0.0.1) None <code>--port</code> integer The port used to run the server (default: 8000) None <code>--log-level</code> text The log level used to run the server (default: info) None <code>--log-config</code> text The path to a file passed to the <code>logging.config.fileConfig</code> function None <code>--option</code>, <code>-o</code> Arbitrary server options (multiple allowed) e.g. -o key1 value1 -o key2 value2 None <code>--help</code>, <code>-h</code> boolean Show this message and exit. <code>False</code>"},{"location":"install/","title":"Installation","text":"<p><code>click-mcp-server</code> is available on PyPI and can be installed with a package manager like pip.</p> <pre><code>pip install click-mcp-server\n</code></pre> <p>Note</p> <p>Applications that are exposed by the server must be installed in the same environment or the <code>PYTHONPATH</code> environment variable must be set appropriately.</p>"}]}